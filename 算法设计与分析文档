首先了解到这个题目是关于多维背包问题，这是一种多约束问题。它带有多组约束，在约束范围内尽可能的将物品多放入背包，使得所求价值最大。
其次是分析数据，第一页有7组数据。第一行三个数，第一个数是物品的种类，第二个是物品的约束种类，第三个数是它的最大价值；接下来第二行分别是每个物品的价值，
后面的数据是有几种约束就有几行，可将这几行用一个二维数据来存储，最后一行是这些物品约束的限制条件。
然后设计：
就第一组数据来讲，先定义物品的总数，NUM=6，然后可以假设定义背包的容量CONTENT，定义一个二维数组m[i][j]对那些约束条件进行存储，由于下标是从0开始的，
所以定义n=NUM-1,并初始化m[n][j]
先看第一组约束，即m[0][j],数据8,12,13,64,22,41，一个一个地放入背包即相加不能大于它的限制条件80
第二组约束，即m[1][j]，数据8,12,13,75,22,41，也是相加不得大于它的约束值96，以此类推，直到遍历完所有组的约束条件，找到符合条件的物品。然后就得出相应的放入背包的物品，
并且将其对应的价值相加，最终得出最大价值。
伪代码如下：
定义 NUM，CONTENT;
int m[NUM ][CONTENT];
初始化 m[n][j]；
for(j = 0; j <= jMax; j++)
m[n][j] = 0;
   for(j = jMax +1; j <= c; j++)
m[n][j] = v[n];
解 m[i][j]；//寻找符合约束条件的物品，并存储到m[i][j]
for(i = n-1) 
 if((w[i]-1)< c)
   jMax = w[i]-1;
       else
   jMax = c;
   for(j = 0)
   m[i][j] = m[i+1][j] ;
    for(j = jMax +1)
    if(m[i+1][j] >= (m[i+1][j-w[i]]+v[i]))
       m[i][j] = m[i+1][j] ;
   else
m[i][j] = m[i+1][j-w[i]]+v[i];
knapsack(value,weight,c,maxvalue);//计算最优值
traceback(flag,weight,maxvalue);//构造最优解
printResult(maxvalue);//打印程序的结果

